---
Date: 2026-01-06
tags:
  - type/practice
  - topic/cloud
aliases:
  - kubernetes
  - configmap
---
## ConfigMap
[Kubernetes Documentation - ConfigMaps](https://kubernetes.io/docs/concepts/configuration/configmap/)
![[Pasted image 20260113161604.png]]
- 컨테이너에서 필요한 환경설정 내용을 컨테이너와 분리해서 제공해 주기 위한 기능
	- Use a ConfigMap for setting configuration data separately from application code.
	- A ConfigMap allows you to decouple environment-specific configuration from your container images,
	- so that your applications are easily **portable.**
- 데이터베이스 주소, 포트 번호, 환경 변수 값 등과 같은 설정 정보를 저장
	- Pods can consume ConfigMaps as environment variables, command-line arguments, or as configuration files in a volume.
### 1. ConfigMaps and Pods
#### 1-1. Kubernetes CLI: ConfigMap 생성
```sh
# ConfigMap 생성 (환경 변수 설정)
$ kubectl create cm jde-cm --from-literal=SECLOUDIT="Platform as a service!"

# ConfigMap 조회
$ kubectl get cm

# ConfigMap 상세 조회
$ kubectl describe cm jde-cm
```
![[Pasted image 20260106104334.png]]
![[Pasted image 20260106104601.png]]
###### Yaml: ConfigMap 생성
```yaml
# configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: jde-cm
  namespace: default
data:  
  SECLOUDIT: "Platform as a service!" 
```
#### 1-2. Pod 생성
```yaml
# cm-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: jde-pod
spec:
  containers:
  - image: busybox
    name: secloudit-container
    env:
    - name: SECLOUDIT_ENV
      valueFrom:
        configMapKeyRef:
          name: jde-cm
          key: SECLOUDIT
    command: ["/bin/sh"]
    args: ["-c", "while true; do echo $(SECLOUDIT_ENV); sleep 10;done"]
    # 10초에 한 번씩 SECLOUDIT 환경 변수에 설정된 문자열을 출력하는 Pod
```
- `spec: containers: env: valueFrom: configMapKeyRef:`
	- Pod가 환경변수를 참조할 `configMapKeyRef`
	- ConfigMap 정보를 정확히 입력해야 함
```sh
# Pod 배포
$ kubectl apply -f cm-pod.yaml

# Pod 목록 조회
$ kubectl get pods -n jde-ns

# Pod 상세 조회
$ kubectl describe pod jde-pod -n jde-ns
```
- `configMapKeyRef`를 수정하지 않아서 에러남
	- `secloudit-configmap`을 앞서 생성한 `jde-cm`으로 수정
#### 1-3. Pod 로그 조회
```sh
# Log 조회
$ kubectl logs -f jde-pod
```
![[Pasted image 20260106105314.png]]
- `SECLOUDIT`의 value를 출력
### 2. ConfigMaps and Pods (2)
#### 2-1. Yaml: ConfigMap 생성
```yaml
# configmap2.yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: jde-cm2
  namespace: jde-ns
data:
  SECLOUDIT: "Platform as a service"
  PaaS: "Secloudit"
```
```sh
# ConfigMap 생성
$ kubectl apply -f configmap2.yaml

# ConfigMap 조회
$ kubectl get cm -n jde-ns

# ConfigMap 상세 조회
$ kubectl describe cm jde-cm2 -n jde-ns
```
![[Pasted image 20260106111120.png]]
###### Kubernetes CLI: ConfigMap 생성
```sh
$ kubectl create configmap jde-cm2 --from-literal=SECLOUDIT="Platform as a service!" --from-literal=PaaS="Secloudit" -n jde-ns
```
#### 2-2. Pod 생성
```sh
# cm-pod2.yaml
apiVersion: v1
kind: Pod
metadata:
  name: jde-pod2
  namespace: jde-ns
spec:
  containers:
  - image: busybox
    name: secloudit-container
    envFrom:
    - configMapRef:
        name: jde-cm2
    command: ["/bin/sh"]
    args: ["-c", "while true; do echo $(SECLOUDIT); sleep 10;done"]
```
```sh
# Pod 생성
$ kubectl apply -f cm-pod2.yaml

# Pod 조회
$ kubectl get pods

# Pod 상세 조회
$ kubectl describe pod jde-pod2 -n jde-ns

# Log 조회
$ kubectl logs jde-pod2 -n jde-ns
```
![[Pasted image 20260106111518.png]]
#### 2-3. Pod 접속
```sh
$ kubectl exec -it jde-pod -- sh
$ kubectl exec -it jde-pod2 -n jde-ns -- sh
```
- Pod에 접속하여 `env`를 입력하면 ConfigMap의 환경변수가 잘 주입된 것을 확인할 수 있다
![[Pasted image 20260106111743.png]]
![[Pasted image 20260106111813.png]]
##### Get a Shell to a Running Container
> [Kubernetes - Get a Shell to a Running Container](https://kubernetes.io/docs/tasks/debug/debug-application/get-shell-running-container/)
> [Blog - How does 'kubectl exec' work?](https://erkanerol.github.io/post/how-kubectl-exec-works/)

- 그냥 궁금했어요!
- [../notes/how-does-kubectl-exec-work](../notes/how-does-kubectl-exec-work)
![Components](https://erkanerol.github.io/img/kubectl-exec/components.png)
1. `kubectl exec process` $\rightarrow$ `master node's api-server`
	- `kubectl` creates a `POST` request with subresource `exec` and sends a rest request
	- We can observe the request in `api-server` side as well
```go
		req := restClient.Post().
			Resource("pods").
			Name(pod.Name).
			Namespace(pod.Namespace).
			SubResource("exec")
		req.VersionedParams(&corev1.PodExecOptions{
			Container: containerName,
			Command:   p.Command,
			Stdin:     p.Stdin,
			Stdout:    p.Out != nil,
			Stderr:    p.ErrOut != nil,
			TTY:       t.Raw,
		}, scheme.ParameterCodec)

		return p.Executor.Execute(req.URL(), p.Config, p.In, p.Out, p.ErrOut, t.Raw, sizeQueue)
```
2. `api-server` $\rightarrow$ `kubelet` (connects)
	- `api-server` receives the request and binds it into a `PodExecOptions`
	- `kubelet` has a port to which `api-server` can connect. (`api-server` knows the endpoint and it opens a connections)
		- `node.Status.DaemonEndpoints.KubeletEndpoint.Port` 
		- [Kubernetes - Control Plane to Node](https://kubernetes.io/docs/concepts/architecture/control-plane-node-communication/#control-plane-to-node)
			- These connections terminate at the kubelet's HTTPS endpoint. By default, the `api-server` does not verify the `kubelet`'s serving certificate.
	- `worker node`'s ip + `kubelet`'s port
3. `Worker Nodes`
	- `kubelet` computes a response endpoint for `exec` requests
		- `kubelet` has a daemon which serves an api over a port for `api-server` requests.
	- `kubelet` implements `RuntimeServiceClient` interface which is part of **Container Runtime** Interface.
	- `kubelet` $\rightarrow$ `Container Runtime`: `RuntimeServiceServer` to implement
4. Container Runtime
	- Container Runtime has a server which implements `RuntimeServiceServer`
		- At the end of the chain, container runtime executes the command in the worker node.
	- `Container Runtime` $\rightarrow$ `Kernel`: `exec Command`
	- Finally, kernel executes commands (executes `sh`)
## Secret
![[Pasted image 20260113185640.png]]
- Password, Auth Token, SSH KEY와 같은 민감한 정보를 저장하는 용도로 사용
- ConfigMap과 달리 value는 인코딩
- [Kubernetes - Using a Secret](https://kubernetes.io/docs/concepts/configuration/secret/#using-a-secret)
	- Secrets can be mounted as data volumes or exposed as environment variables to be used by a container in a Pod.
### 1. Secrets and Pods
#### 1-1. Kubernetes CLI: Secret 생성
```sh
# Secret 생성
$ kubectl create secret generic jde-secret --from-literal=SECLOUDIT="Platform as a service!" -n jde-ns

# Secret 조회
$ kubectl get secret -n jde-ns

# Secret 상세 조회
# default: Opaque
$ kubectl describe secret jde-secret -n jde-ns
```
![[Pasted image 20260106114241.png]]
- `Opaque`: the default secret type
#### 1-2. Pod 생성
```yaml
# secret-pod.yaml

apiVersion: v1
kind: Pod
metadata:
  name: jde-secret-pod
  namespace: jde-ns
spec:
  containers:
  - image: busybox
    name: secloudit-container
    env:
    - name: SECLOUDIT_ENV
      valueFrom:
        secretKeyRef:
          name: jde-secret    # Secret 연결
          key: SECLOUDIT
    command: ["/bin/sh"]
    args: ["-c", "while true; do echo $(SECLOUDIT_ENV); sleep 10;done"]
```
```sh
# Pod 생성
$ kubectl apply -f secret-pod.yaml

# Pod 조회
$ kubectl get pods -n jde-ns

# Pod 로그 조회
$ kubectl logs jde-secret-pod -n jde-ns
```
![[Pasted image 20260106114719.png]]
- Secret에 설정된 `SECLOUDIT`의 value 출력
### 2. Secrets and Pods (2)
#### 2-1. Yaml: Secret 생성
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: jde-secret2
  namespace: jde-ns
type: Opaque
data:
  SECLOUDIT: UGxhdGZvcm0gYXMgYSBzZXJ2aWNlIQ==
  PaaS: U2VjbG91ZGl0Cg==
```
![[Pasted image 20260106115738.png]]
- `value`는 인코딩
![[Pasted image 20260106115945.png]]
```sh
# Secret 생성
kubectl create -f secret2.yaml
```
![[Pasted image 20260106120617.png]]
#### 2-2. Pod 생성
```yaml
# secret-pod2.yaml

apiVersion: v1
kind: Pod
metadata:
  name: jde-secret-pod2
  namespace: jde-ns
spec:
  containers:
  - image: busybox
    name: secloudit-container
    envFrom:
      secretKeyRef:
         name: jde-secret2  # Secret 연결
    command: ["/bin/sh"]
    args: ["-c", "while true; do echo $(SECLOUDIT); sleep 10;done"]
```
- `secretKeyRef`를 `secretRef`로 수정
	- 
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: jde-secret-pod2
  namespace: jde-ns
spec:
  containers:
  - image: busybox
    name: secloudit-container
    envFrom:
    - secretRef:
         name: jde-secret2
    command: ["/bin/sh"]
    args: ["-c", "while true; do echo $(SECLOUDIT); sleep 10;done"]
```

```sh
# Pod 생성
$ kubectl apply -f secret2.yaml

# Pod 조회
$ kubectl get pods -n jde-ns

# log 조회
$ kubectl logs jde-secret-pod2 -n jde-ns
```
![[Pasted image 20260106120855.png]]
- Secret에서 설정한 `value` 출력
#### 2-3. Pod 접속
- Pod 접속하여 환경변수 설정 확인
```sh
$ kubectl exec -it jde-secret-pod2 -n jde-ns -- sh
```
![[Pasted image 20260106121010.png]]
- Secret 자체는 암호화된 상태로 관리
	- api-server나 node 간 통신에서는 보호됨
- Pod 내부에서는 Plain Text로 보임
	- Pod가 생성될 때 메모리 상에서 디코딩하여 환경변수로 꽂아줌
		- 파일로 꽂아주려면 `volumeMount` 옵션
	- Pod 접속 권한을 관리해야 하는 거 아닌가 그럼...?
- Secret 값이 변경되었을 때 Pod를 Restart 해야함.
### 3. Secret Volume
- Pod 내에서 환경변수가 아니라 파일을 mount해서 사용함.
- 환경변수보다 권한을 관리하기에 용이
#### 3-1. Pod 생성
- 2-1에서 생성한 secret 재사용
```yaml
# secret-pod3.yaml

apiVersion: v1
kind: Pod
metadata:
  name: jde-secret-pod3
  namespace: jde-ns
spec:
  containers:
  - image: redis
    name: secloudit-container
    volumeMounts:                 # Pod에 Storage 할당 (영구)
    - name: secloudit-volume
      mountPath: "/secrets"       # Pod 내 컨테이너가 사용할 스토리지 볼륨 경로 지정
      readOnly: true              # 읽기 전용으로 마운트 (수정 불가)
  volumes:
  - name: secloudit-volume
    secret:
      secretName: jde-secret2  # secret 지정
```
```sh
# Pod 생성
$ kubectl apply -f secret-pod3.yaml

# Pod 목록 조회
$ kubectl get pods -n jde-ns

# Pod 로그 조회
$ kubectl logs jde-secret-pod3 -n jde-ns

# Pod 접속하여 shell 프로세스 실행
$ kubectl exec -it jde-secret-pod3 -n jde-ns -- sh
```
![[Pasted image 20260106121917.png]]
![[Pasted image 20260106122027.png]]
- Secret을 환경변수로 주입했을 때와 다르게 Volume으로 마운트하여 사용하면 
- 로그(위)나 프로세스 환경변수 정보(아래)에 Plain Text로 노출되지 않음
#### 3-2. Pod 접속
```sh
$ kubectl exec -it jde-secret-pod3 -n jde-ns -- sh
```
![[Pasted image 20260106122333.png]]
- Pod 생성 시 설정한 mount 경로: `/secrets`에서
	- `PaaS`와 `SECLOUDIT`의 value를 확인할 수 있음.
## DaemonSet
[Kubernetes - DaemonSet](https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/)
- Typical uses of a DaemonSet:
	- running a cluster storage daemon on every node
	- running a logs collection daemon on every node
	- running a node monitoring daemon on every node
### 1. DaemonSet 생성
#### 1-1. Yaml: Writing a DaemonSet Spec 
```sh
# daemonset.yaml

apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: jde-daemonset
  namespace: kube-system  #로그 수집기는 관리용 파드나 설정에 해당 되므로 kube-system 네임스페이스로 지정
  labels:
    k8s-app: fluentd-logging
spec:
  selector:                # DaemonSet이 관리할 Pod를 식별하는 데 사용
    matchLabels:
      name: fluentd-elasticsearch
  template:                # DaemonSet이 관리(생성)하는 Pod 세부 설정
    metadata:
      labels:
        name: fluentd-elasticsearch   # selector의 matchLabels와 같아야 함
    spec:
      tolerations: # 데몬셋이 컨트롤 플레인 노드에서 실행될 수 있도록 만든다.
      - key: node-role.kubernetes.io/control-plane
        operator: Exists
        effect: NoSchedule
      - key: node-role.kubernetes.io/master
        operator: Exists
        effect: NoSchedule
      containers:            # Pod 안에 포함될 컨테이너 설정
      - name: secloudit-container  
        image: quay.io/fluentd_elasticsearch/fluentd:v2.5.2
        volumeMounts:        # 아래에서 설정한 volume을 컨테이너의 어디에서 사용할 거
        - name: secloudit-log # 이름 통일해야 함
          mountPath: /var/log # 컨테이너 내 경로
      terminationGracePeriodSeconds: 30
      volumes:                # 볼륨 생성
      - name: secloudit-log   
        hostPath:
          path: /var/log      # 현재 노드에서의 경로
```
- `volumes`: 현재 노드에서 사용할 저장 공간
- `volumeMounts`: `volumes`를 mount할 컨테이너 내 저장 공간 (Zero Copy, Bind Mount)
- `volumes`와 `volumeMounts`는 물리적으로 동일한 공간이므로 동기화 불필요, 실시간 반영
```sh
# daemonset 생성
$ kubectl apply -f daemonset.yaml

# Pod 조회
$ kubectl get pods -n kube-system
```
![[Pasted image 20260106123036.png]]
- DaemonSet이 생성한 Pod 4개 Running

- Worker Node에 Floating IP를 달면 `ImagePullBackOff`가 발생하지 않는 이유
	- Public이라 용량 제한 걸린 건데
	- 마스터를 거치지 않고 Worker Node가 직접 Docker Hub에 접속해서 다운
